package com.time2key.modularmockserver

import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.RecordedRequest
import java.util.regex.PatternSyntaxException
import kotlin.RuntimeException
import kotlin.reflect.KCallable
import kotlin.reflect.KClass
import kotlin.reflect.KFunction
import kotlin.reflect.KVisibility

abstract class DispatcherModule {

    /**
     * Cached list of all functions in this instance which are annotated with [ServerPath]
     *
     * Setup by [setupAnnotatedFunctions]
     * */
    val serverPathAnnotatedFunctions = ArrayList<ServerPathAnnotatedFunction>()


    /**
     * This is called once by [MultiModuleDispatcher] to populate [serverPathAnnotatedFunctions]
     *
     * This will look for an [AutoGeneratedDispatcherModule] corresponding with this class, which
     * will have been generated by [ServerPathAnnotationProcessor] and get precompiled values
     * out of that.
     *
     * @param canUseReflectionFallback
     * If true (not recommended), this will fallback to using Reflection to look for annotated
     * functions if the class generated by the annotation processor cannot be found.
     * */
    fun setupAnnotatedFunctions(canUseReflectionFallback: Boolean) {
        serverPathAnnotatedFunctions.clear()

        if (canUseReflectionFallback) {
            this::class.members.forEach { member ->
                member.annotations
                        .filterIsInstance<ServerPath>()
                        .forEach { serverPathAnnotation ->

                            assertFunctionIsValidForAnnotation(member, serverPathAnnotation)

                            serverPathAnnotatedFunctions.add(
                                    ReflectionObtainedServerPathAnnotatedFunction(
                                            this,
                                            serverPathAnnotation,
                                            member as KFunction<MockResponse>))
                        }
            }
        }
    }

    /**
     * Asserts that a given function has a valid signature corresponding to a given [ServerPath]
     * annotation.
     *
     * If it does not, an exception is thrown describing what is wrong.
     * */
    private fun assertFunctionIsValidForAnnotation(member: KCallable<*>, annotation: ServerPath) {
        if (member.visibility != KVisibility.PUBLIC) {
            throw java.lang.RuntimeException("ServerPath-annotated function ${member.name} must have public visibility")
        }

        if (member.returnType.classifier != MockResponse::class) {
            val actualReturnTypeString = (member.returnType.classifier as? KClass<*>)?.simpleName ?: "(unknown)"
            throw RuntimeException("ServerPath-annotated function ${member.name} has return type ${actualReturnTypeString} - must be MockResponse")
        }

        val matchingPathRegex = try {
             Regex(annotation.matchingPathRegex)
        } catch (e: PatternSyntaxException) {
            throw RuntimeException("ServerPath annotation for function ${member.name} has invalid Regex", e)
        }

        var doParametersMatch = true
        val totalRegexGroupCount = matchingPathRegex.toPattern().matcher("").groupCount()
        // Minus one because the first 'parameter' is the instance itself and not a parameter:
        val numberOfParameters = member.parameters.size - 1

        if (numberOfParameters - 1 != totalRegexGroupCount) {
            doParametersMatch = false
        } else {
            member.parameters.forEachIndexed { index, kParameter ->
                if (index == 0) {
                    // Do nothing when index == 0 as this index corresponds to the instance that the
                    // function is on (the DispatcherModule instance) rather than an actual parameter.
                    return@forEachIndexed
                }
                if (index == 1 && kParameter.type.classifier != RecordedRequest::class) {
                    doParametersMatch = false
                }
                if (index > 1 && kParameter.type.classifier != String::class) {
                    doParametersMatch = false
                }
            }
        }

        if (!doParametersMatch) {
            val stringBuilder = StringBuilder()

            stringBuilder.append("ServerPath-annotated function ${member.name} must take RecordedRequest parameter, and one parameter for each capturing group in the ServerPath regex\n")
            stringBuilder.append("Regex pattern ${matchingPathRegex.pattern} has ${totalRegexGroupCount} capturing groups\n")
            stringBuilder.append("Expected arguments (RecordedRequest")
            for (i in 0 until totalRegexGroupCount - 1) {
                stringBuilder.append(", String")
            }
            stringBuilder.append(") - received arguments (")
            member.parameters.forEachIndexed { index, kParameter ->
                if (index == 0) {
                    // Do nothing when index == 0 as this index corresponds to the instance that the
                    // function is on (the DispatcherModule instance) rather than an actual parameter.
                    return@forEachIndexed
                }
                if (index > 1) stringBuilder.append(", ")
                stringBuilder.append((kParameter.type.classifier as? KClass<*>)?.simpleName ?: "(unknown)")
            }
            stringBuilder.append(")")

            throw RuntimeException(stringBuilder.toString())
        }
    }


    /**
     * A [ServerPathAnnotatedFunction] that has been obtained via Reflection at runtime.
     * */
    protected class ReflectionObtainedServerPathAnnotatedFunction(
            private val dispatcherModule: DispatcherModule,
            serverPath: ServerPath,
            val function: KFunction<MockResponse>
    ): ServerPathAnnotatedFunction() {

        override val dispatcherModuleSimpleClassName: String by lazy { dispatcherModule::class.java.simpleName }

        override val simpleFunctionName: String by lazy { function.name }

        override val matchingPathRegex: Regex = Regex(serverPath.matchingPathRegex)

        override val priorityIfMultiplePathsMatch = serverPath.priorityIfMultiplePathsMatch

        override fun evaluateRequest(request: RecordedRequest): MockResponse {
            val matchResult = matchingPathRegex.matchEntire(request.path)!!
            val groupValues = arrayOfNulls<String>(matchResult.groupValues.size - 1)


            matchResult.groupValues.forEachIndexed { index, groupValue ->
                if (index > 0) {
                    groupValues[index - 1] = groupValue
                }
            }
            return function.call(dispatcherModule, *groupValues)
        }

    }

}